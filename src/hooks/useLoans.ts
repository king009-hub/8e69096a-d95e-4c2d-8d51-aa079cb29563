import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/components/ui/use-toast";
import { CustomerLoan, LoanItem, LoanPayment } from "@/types/loans";
import { CartItem } from "@/types/inventory";

export function useLoans() {
  const [loans, setLoans] = useState<CustomerLoan[]>([]);
  const [loading, setLoading] = useState(true);
  const { toast } = useToast();

  const fetchLoans = async () => {
    try {
      const { data, error } = await supabase
        .from('customer_loans')
        .select(`
          *,
          customer:customers(id, name, phone)
        `)
        .order('created_at', { ascending: false });

      if (error) throw error;
      
      // Update overdue status for active loans
      const loansData = (data || []) as any;
      const now = new Date();
      
      for (const loan of loansData) {
        if (loan.status === 'active' && loan.due_date) {
          const dueDate = new Date(loan.due_date);
          if (dueDate < now && loan.remaining_amount > 0) {
            await supabase
              .from('customer_loans')
              .update({ status: 'overdue' })
              .eq('id', loan.id);
            loan.status = 'overdue';
          }
        }
      }
      
      setLoans(loansData);
    } catch (error) {
      console.error('Error fetching loans:', error);
      toast({
        title: "Error",
        description: "Failed to fetch loans",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const createLoan = async (
    customerId: string,
    items: CartItem[],
    dueDate?: string,
    interestRate?: number,
    notes?: string
  ) => {
    try {
      const totalAmount = items.reduce((sum, item) => sum + (item.unit_price * item.quantity), 0);

      // Create the loan (loan_number will be auto-generated by trigger)
      const loanData: any = {
        customer_id: customerId,
        total_amount: totalAmount,
        remaining_amount: totalAmount,
      };
      
      if (dueDate) loanData.due_date = dueDate;
      if (interestRate) loanData.interest_rate = interestRate;
      if (notes) loanData.notes = notes;

      const { data: loan, error: loanError } = await supabase
        .from('customer_loans')
        .insert(loanData)
        .select()
        .single();

      if (loanError) throw loanError;

      // Create loan items
      const loanItems = items.map(item => ({
        loan_id: loan.id,
        product_id: item.product.id,
        quantity: item.quantity,
        unit_price: item.unit_price,
        total_price: item.unit_price * item.quantity
      }));

      const { error: itemsError } = await supabase
        .from('loan_items')
        .insert(loanItems);

      if (itemsError) throw itemsError;

      // Create stock movements and deduct from batches for each item
      for (const item of items) {
        // If product has batches, deduct from them (FIFO)
        const { data: batches } = await supabase
          .from('product_batches')
          .select('*')
          .eq('product_id', item.product.id)
          .gt('quantity', 0)
          .order('received_date', { ascending: true });

        let remainingQty = item.quantity;
        
        if (batches && batches.length > 0) {
          // Deduct from batches
          for (const batch of batches) {
            if (remainingQty <= 0) break;
            
            const deductQty = Math.min(batch.quantity, remainingQty);
            
            await supabase
              .from('product_batches')
              .update({ quantity: batch.quantity - deductQty })
              .eq('id', batch.id);
            
            await supabase
              .from('stock_movements')
              .insert({
                product_id: item.product.id,
                batch_id: batch.id,
                movement_type: 'out',
                quantity: deductQty,
                reason: 'Loan',
                reference_id: loan.id
              });
            
            remainingQty -= deductQty;
          }
        } else {
          // No batches, deduct from main stock
          await supabase
            .from('stock_movements')
            .insert({
              product_id: item.product.id,
              movement_type: 'out',
              quantity: item.quantity,
              reason: 'Loan',
              reference_id: loan.id
            });
        }
      }

      toast({
        title: "Success",
        description: "Loan created successfully",
      });

      await fetchLoans();
      return loan;
    } catch (error) {
      console.error('Error creating loan:', error);
      toast({
        title: "Error",
        description: "Failed to create loan",
        variant: "destructive",
      });
      throw error;
    }
  };

  const addPayment = async (
    loanId: string,
    amount: number,
    paymentMethod: string,
    referenceNumber?: string,
    notes?: string
  ) => {
    try {
      const { error } = await supabase
        .from('loan_payments')
        .insert([{
          loan_id: loanId,
          amount: amount,
          payment_method: paymentMethod,
          reference_number: referenceNumber,
          notes: notes
        }]);

      if (error) throw error;

      toast({
        title: "Success",
        description: "Payment recorded successfully",
      });

      await fetchLoans();
    } catch (error) {
      console.error('Error adding payment:', error);
      toast({
        title: "Error",
        description: "Failed to record payment",
        variant: "destructive",
      });
      throw error;
    }
  };

  const getLoanItems = async (loanId: string): Promise<LoanItem[]> => {
    try {
      const { data, error } = await supabase
        .from('loan_items')
        .select(`
          *,
          products!inner(id, name)
        `)
        .eq('loan_id', loanId);

      if (error) throw error;
      return (data || []) as any;
    } catch (error) {
      console.error('Error fetching loan items:', error);
      return [];
    }
  };

  const getLoanPayments = async (loanId: string): Promise<LoanPayment[]> => {
    try {
      const { data, error } = await supabase
        .from('loan_payments')
        .select('*')
        .eq('loan_id', loanId)
        .order('payment_date', { ascending: false });

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Error fetching loan payments:', error);
      return [];
    }
  };

  useEffect(() => {
    fetchLoans();
  }, []);

  return {
    loans,
    loading,
    createLoan,
    addPayment,
    getLoanItems,
    getLoanPayments,
    refreshLoans: fetchLoans,
  };
}