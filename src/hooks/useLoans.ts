import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/components/ui/use-toast";
import { CustomerLoan, LoanItem, LoanPayment } from "@/types/loans";
import { CartItem } from "@/types/inventory";

export function useLoans() {
  const [loans, setLoans] = useState<CustomerLoan[]>([]);
  const [loading, setLoading] = useState(true);
  const { toast } = useToast();

  const fetchLoans = async () => {
    try {
      const { data, error } = await supabase
        .from('customer_loans')
        .select(`
          *,
          customer:customers(id, name, phone)
        `)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setLoans((data || []) as any);
    } catch (error) {
      console.error('Error fetching loans:', error);
      toast({
        title: "Error",
        description: "Failed to fetch loans",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const createLoan = async (
    customerId: string,
    items: CartItem[],
    dueDate?: string,
    interestRate?: number,
    notes?: string
  ) => {
    try {
      const totalAmount = items.reduce((sum, item) => sum + (item.unit_price * item.quantity), 0);

      // Create the loan (loan_number will be auto-generated by trigger)
      const loanData: any = {
        customer_id: customerId,
        total_amount: totalAmount,
        remaining_amount: totalAmount,
      };
      
      if (dueDate) loanData.due_date = dueDate;
      if (interestRate) loanData.interest_rate = interestRate;
      if (notes) loanData.notes = notes;

      const { data: loan, error: loanError } = await supabase
        .from('customer_loans')
        .insert(loanData)
        .select()
        .single();

      if (loanError) throw loanError;

      // Create loan items
      const loanItems = items.map(item => ({
        loan_id: loan.id,
        product_id: item.product.id,
        quantity: item.quantity,
        unit_price: item.unit_price,
        total_price: item.unit_price * item.quantity
      }));

      const { error: itemsError } = await supabase
        .from('loan_items')
        .insert(loanItems);

      if (itemsError) throw itemsError;

      // Create stock movements for each item
      for (const item of items) {
        await supabase
          .from('stock_movements')
          .insert({
            product_id: item.product.id,
            movement_type: 'out',
            quantity: item.quantity,
            reason: 'Loan',
            reference_id: loan.id
          });
      }

      toast({
        title: "Success",
        description: "Loan created successfully",
      });

      await fetchLoans();
      return loan;
    } catch (error) {
      console.error('Error creating loan:', error);
      toast({
        title: "Error",
        description: "Failed to create loan",
        variant: "destructive",
      });
      throw error;
    }
  };

  const addPayment = async (
    loanId: string,
    amount: number,
    paymentMethod: string,
    referenceNumber?: string,
    notes?: string
  ) => {
    try {
      const { error } = await supabase
        .from('loan_payments')
        .insert([{
          loan_id: loanId,
          amount: amount,
          payment_method: paymentMethod,
          reference_number: referenceNumber,
          notes: notes
        }]);

      if (error) throw error;

      toast({
        title: "Success",
        description: "Payment recorded successfully",
      });

      await fetchLoans();
    } catch (error) {
      console.error('Error adding payment:', error);
      toast({
        title: "Error",
        description: "Failed to record payment",
        variant: "destructive",
      });
      throw error;
    }
  };

  const getLoanItems = async (loanId: string): Promise<LoanItem[]> => {
    try {
      const { data, error } = await supabase
        .from('loan_items')
        .select(`
          *,
          products!inner(id, name)
        `)
        .eq('loan_id', loanId);

      if (error) throw error;
      return (data || []) as any;
    } catch (error) {
      console.error('Error fetching loan items:', error);
      return [];
    }
  };

  const getLoanPayments = async (loanId: string): Promise<LoanPayment[]> => {
    try {
      const { data, error } = await supabase
        .from('loan_payments')
        .select('*')
        .eq('loan_id', loanId)
        .order('payment_date', { ascending: false });

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Error fetching loan payments:', error);
      return [];
    }
  };

  useEffect(() => {
    fetchLoans();
  }, []);

  return {
    loans,
    loading,
    createLoan,
    addPayment,
    getLoanItems,
    getLoanPayments,
    refreshLoans: fetchLoans,
  };
}