import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { Sale, SaleItem, CartItem } from "@/types/inventory";
import { useToast } from "@/components/ui/use-toast";

export function useSales() {
  const [sales, setSales] = useState<Sale[]>([]);
  const [loading, setLoading] = useState(true);
  const { toast } = useToast();

  const fetchSales = async () => {
    try {
      const { data, error } = await supabase
        .from('sales')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) throw error;
      setSales(data || []);
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to fetch sales",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const createSale = async (
    saleData: Omit<Sale, 'id' | 'sale_number' | 'created_at'>,
    items: CartItem[],
    customerId?: string
  ) => {
    try {
      // First, validate stock availability using FEFO logic
      const stockValidation = await validateStockAvailability(items);
      if (!stockValidation.canFulfill) {
        throw new Error(`Insufficient stock for some products`);
      }

      // Create the sale (sale_number will be auto-generated by trigger)
      const { data: sale, error: saleError } = await supabase
        .from('sales')
        .insert([{ 
          ...saleData, 
          sale_number: '', 
          customer_id: customerId
        }])
        .select()
        .single();

      if (saleError) throw saleError;

      // Create sale items with batch allocation using FEFO
      const saleItems = [];
      for (const item of items) {
        const batchAllocations = await allocateFromBatches(item.product.id, item.quantity);
        
        for (const allocation of batchAllocations) {
          saleItems.push({
            sale_id: sale.id,
            product_id: item.product.id,
            batch_id: allocation.batch_id,
            quantity: allocation.quantity,
            unit_price: allocation.selling_price,
            total_price: allocation.quantity * allocation.selling_price
          });
        }
      }

      const { error: itemsError } = await supabase
        .from('sale_items')
        .insert(saleItems);

      if (itemsError) throw itemsError;

      setSales(prev => [sale, ...prev]);
      toast({
        title: "Success",
        description: `Sale ${sale.sale_number} created successfully`,
      });
      
      return sale;
    } catch (error) {
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to create sale",
        variant: "destructive",
      });
      throw error;
    }
  };

  const validateStockAvailability = async (items: CartItem[]) => {
    const productIds = items.map(item => item.product.id);
    
    const { data: batches, error } = await supabase
      .from('product_batches')
      .select('product_id, quantity, expiry_date')
      .in('product_id', productIds)
      .gt('quantity', 0);

    if (error) throw error;

    let canFulfill = true;
    for (const item of items) {
      const productBatches = batches?.filter(b => b.product_id === item.product.id) || [];
      const totalAvailable = productBatches.reduce((sum, batch) => sum + batch.quantity, 0);
      
      if (totalAvailable < item.quantity) {
        canFulfill = false;
        break;
      }
    }

    return { canFulfill };
  };

  const allocateFromBatches = async (productId: string, quantity: number) => {
    // Get batches ordered by expiry date (FEFO - First Expired First Out)
    const { data: batches, error } = await supabase
      .from('product_batches')
      .select('id, quantity, selling_price, expiry_date')
      .eq('product_id', productId)
      .gt('quantity', 0)
      .order('expiry_date', { ascending: true, nullsFirst: false })
      .order('created_at', { ascending: true });

    if (error) throw error;

    const allocations = [];
    let remainingQuantity = quantity;

    for (const batch of batches || []) {
      if (remainingQuantity <= 0) break;

      const takeQuantity = Math.min(batch.quantity, remainingQuantity);
      allocations.push({
        batch_id: batch.id,
        quantity: takeQuantity,
        selling_price: batch.selling_price
      });

      remainingQuantity -= takeQuantity;
    }

    if (remainingQuantity > 0) {
      throw new Error(`Insufficient stock for product ${productId}`);
    }

    return allocations;
  };

  const getSaleItems = async (saleId: string) => {
    try {
      const { data, error } = await supabase
        .from('sale_items')
        .select(`
          *,
          product:products(*)
        `)
        .eq('sale_id', saleId);

      if (error) throw error;
      return data;
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to fetch sale items",
        variant: "destructive",
      });
      throw error;
    }
  };

  useEffect(() => {
    fetchSales();
  }, []);

  return {
    sales,
    loading,
    createSale,
    getSaleItems,
    refreshSales: fetchSales,
  };
}